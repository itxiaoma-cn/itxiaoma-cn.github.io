<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GOPL06-接口 | IT小马</title>
  <meta name="keywords" content=" GO , GOPL ">
  <meta name="description" content="GOPL06-接口 | IT小马">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="CURD操作及分页安装配置依赖库 lodash是常用的工具库 typeorm一个TS编写的node.js ORM @nestjs&#x2F;typeorm Nestjs的TypeOrm整合模块 mysql2是Node的Mysql操作库 sanitize-html过滤html标签,防注入攻击 @nestjs&#x2F;platform-fastify是Nestjs适配fastify框架的HTTP驱动  1pnpm ad">
<meta property="og:type" content="article">
<meta property="og:title" content="02CURD操作及分页">
<meta property="og:url" content="https://blog.itxiaoma.cn/2023/08/02/Nest02/index.html">
<meta property="og:site_name" content="IT小马">
<meta property="og:description" content="CURD操作及分页安装配置依赖库 lodash是常用的工具库 typeorm一个TS编写的node.js ORM @nestjs&#x2F;typeorm Nestjs的TypeOrm整合模块 mysql2是Node的Mysql操作库 sanitize-html过滤html标签,防注入攻击 @nestjs&#x2F;platform-fastify是Nestjs适配fastify框架的HTTP驱动  1pnpm ad">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-01T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-21T10:40:19.477Z">
<meta property="article:author" content="IT小马">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="Nest">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar1.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.0.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar1.jpg"/>
</a>
<div class="author">
    <span>IT小马</span>
</div>

<div class="icon">
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(153)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="GO">
            
            GO
            <small>(30)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="PHP">
            <i class="fold iconfont icon-right"></i>
            PHP
            <small>(12)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="PHP&lt;---&gt;基础">
            
            基础
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="PHP&lt;---&gt;中间件">
            
            中间件
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="PHP&lt;---&gt;Laravel">
            
            Laravel
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="PHP&lt;---&gt;Symfony">
            
            Symfony
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JAVA">
            
            JAVA
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="MYSQL">
            
            MYSQL
            <small>(11)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="REDIS">
            
            REDIS
            <small>(18)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="DOCKER">
            
            DOCKER
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="K8S">
            <i class="fold iconfont icon-right"></i>
            K8S
            <small>(31)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="K8S&lt;---&gt;K3S">
            
            K3S
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="K8S&lt;---&gt;K8S基础">
            
            K8S基础
            <small>(11)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="K8S&lt;---&gt;K8S架构师">
            
            K8S架构师
            <small>(15)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="WEB">
            
            WEB
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="前端">
            <i class="fold iconfont icon-right"></i>
            前端
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="前端&lt;---&gt;CSS">
            
            CSS
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="前端&lt;---&gt;ES6">
            
            ES6
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="前端&lt;---&gt;HTML">
            
            HTML
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="前端&lt;---&gt;JS">
            
            JS
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="前端&lt;---&gt;Nest">
            
            Nest
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="前端&lt;---&gt;Vue">
            
            Vue
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试">
            
            面试
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="英语">
            <i class="fold iconfont icon-right"></i>
            英语
            <small>(2)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="英语&lt;---&gt;语法">
            
            语法
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="游戏">
            
            游戏
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="运维">
            
            运维
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        <a 
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="153">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>后端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>容器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>学习笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>英语</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>游戏</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>语法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>运维</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CKA</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Cocos</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DOCKER</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ELK</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ES6</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>GO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>GOPL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTML</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Jmeter</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>K3S</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>K8S</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Laravel</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MYSQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Nest</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>PHP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RabbitMQ</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>REDIS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Swoole</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Symfony</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WEB</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 前端 Nest "
           href="/2023/08/02/Nest02/"
           data-tag="前端,Nest"
           data-author="" >
            <span class="post-title" title="02CURD操作及分页">02CURD操作及分页</span>
            <span class="post-date" title="2023-08-02 00:00:00">2023/08/02</span>
        </a>
        
        
        <a  class="全部文章 前端 Nest "
           href="/2023/08/01/Nest01/"
           data-tag="前端,Nest"
           data-author="" >
            <span class="post-title" title="01TS核心概念">01TS核心概念</span>
            <span class="post-date" title="2023-08-01 00:00:00">2023/08/01</span>
        </a>
        
        
        <a  class="全部文章 PHP Symfony "
           href="/2023/07/04/Symfony04/"
           data-tag="PHP,Symfony"
           data-author="" >
            <span class="post-title" title="Symfony04">Symfony04</span>
            <span class="post-date" title="2023-07-04 00:00:00">2023/07/04</span>
        </a>
        
        
        <a  class="全部文章 PHP Symfony "
           href="/2023/07/03/Symfony03/"
           data-tag="PHP,Symfony"
           data-author="" >
            <span class="post-title" title="Symfony03">Symfony03</span>
            <span class="post-date" title="2023-07-03 00:00:00">2023/07/03</span>
        </a>
        
        
        <a  class="全部文章 PHP Symfony "
           href="/2023/07/02/Symfony02/"
           data-tag="PHP,Symfony"
           data-author="" >
            <span class="post-title" title="Symfony02">Symfony02</span>
            <span class="post-date" title="2023-07-02 00:00:00">2023/07/02</span>
        </a>
        
        
        <a  class="全部文章 PHP Symfony "
           href="/2023/07/01/Symfony01/"
           data-tag="PHP,Symfony"
           data-author="" >
            <span class="post-title" title="Symfony01">Symfony01</span>
            <span class="post-date" title="2023-07-01 00:00:00">2023/07/01</span>
        </a>
        
        
        <a  class="全部文章 英语 语法 "
           href="/2023/07/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%9501%E6%A1%86%E6%9E%B6/"
           data-tag="英语,语法"
           data-author="" >
            <span class="post-title" title="01语法框架">01语法框架</span>
            <span class="post-date" title="2023-07-01 00:00:00">2023/07/01</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2023/06/03/Go%E5%AE%9E%E6%88%9803/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题03-实战">Go面试题03-实战</span>
            <span class="post-date" title="2023-06-03 00:00:00">2023/06/03</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2023/06/02/Go%E5%AE%9E%E6%88%9802/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题02-进阶">Go面试题02-进阶</span>
            <span class="post-date" title="2023-06-02 00:00:00">2023/06/02</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2023/06/01/Go%E5%AE%9E%E6%88%9801/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题01-基础">Go面试题01-基础</span>
            <span class="post-date" title="2023-06-01 00:00:00">2023/06/01</span>
        </a>
        
        
        <a  class="全部文章 运维 "
           href="/2023/05/03/ElasticSearh03%E6%A6%82%E5%BF%B5/"
           data-tag="后端,ELK"
           data-author="" >
            <span class="post-title" title="ElasticSearh 03概念">ElasticSearh 03概念</span>
            <span class="post-date" title="2023-05-03 00:00:00">2023/05/03</span>
        </a>
        
        
        <a  class="全部文章 运维 "
           href="/2023/05/02/ElasticSearh02%E6%90%AD%E5%BB%BA/"
           data-tag="后端,ELK"
           data-author="" >
            <span class="post-title" title="ElasticSearh 02环境搭建">ElasticSearh 02环境搭建</span>
            <span class="post-date" title="2023-05-02 00:00:00">2023/05/02</span>
        </a>
        
        
        <a  class="全部文章 运维 "
           href="/2023/05/01/ElasticSearh01%E5%8E%9F%E7%90%86/"
           data-tag="后端,ELK"
           data-author="" >
            <span class="post-title" title="ElasticSearh 01原理">ElasticSearh 01原理</span>
            <span class="post-date" title="2023-05-01 00:00:00">2023/05/01</span>
        </a>
        
        
        <a  class="全部文章 K8S "
           href="/2023/01/01/CKA%E8%AE%A4%E8%AF%8101/"
           data-tag="K8S,CKA"
           data-author="" >
            <span class="post-title" title="CKA认证01">CKA认证01</span>
            <span class="post-date" title="2023-01-01 00:00:00">2023/01/01</span>
        </a>
        
        
        <a  class="全部文章 K8S K3S "
           href="/2022/12/04/K3S04-%E5%AE%89%E8%A3%85Mysql%E9%9B%86%E7%BE%A4/"
           data-tag="K8S,容器,K3S"
           data-author="" >
            <span class="post-title" title="K3S03-安装Mysql集群">K3S03-安装Mysql集群</span>
            <span class="post-date" title="2022-12-04 00:00:00">2022/12/04</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/12/04/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B031-38/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis核心技术笔记31-38">Redis核心技术笔记31-38</span>
            <span class="post-date" title="2022-12-04 00:00:00">2022/12/04</span>
        </a>
        
        
        <a  class="全部文章 K8S K3S "
           href="/2022/12/03/K3S03-%E5%AE%89%E8%A3%85Rancher/"
           data-tag="K8S,容器,K3S"
           data-author="" >
            <span class="post-title" title="K3S03-安装Rancher">K3S03-安装Rancher</span>
            <span class="post-date" title="2022-12-03 00:00:00">2022/12/03</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/12/03/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B021-30/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis核心技术笔记21-30">Redis核心技术笔记21-30</span>
            <span class="post-date" title="2022-12-03 00:00:00">2022/12/03</span>
        </a>
        
        
        <a  class="全部文章 K8S K3S "
           href="/2022/12/02/K3S02-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"
           data-tag="K8S,容器,K3S"
           data-author="" >
            <span class="post-title" title="K3S02-基础使用">K3S02-基础使用</span>
            <span class="post-date" title="2022-12-02 00:00:00">2022/12/02</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/12/02/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B011-20/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis核心技术笔记11-20">Redis核心技术笔记11-20</span>
            <span class="post-date" title="2022-12-02 00:00:00">2022/12/02</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/12/01/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B001-10/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis核心技术笔记01-10">Redis核心技术笔记01-10</span>
            <span class="post-date" title="2022-12-01 00:00:00">2022/12/01</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/11/09/Go%E7%AC%94%E8%AE%B001-Go%E5%9F%BA%E7%A1%80/"
           data-tag="GO,学习笔记"
           data-author="" >
            <span class="post-title" title="Go笔记01-Go基础">Go笔记01-Go基础</span>
            <span class="post-date" title="2022-11-09 00:00:00">2022/11/09</span>
        </a>
        
        
        <a  class="全部文章 PHP 中间件 "
           href="/2022/11/06/PHP-RabbitMQ-2%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"
           data-tag="PHP,RabbitMQ"
           data-author="" >
            <span class="post-title" title="PHP-RabbitMQ-2高级特性">PHP-RabbitMQ-2高级特性</span>
            <span class="post-date" title="2022-11-06 00:00:00">2022/11/06</span>
        </a>
        
        
        <a  class="全部文章 PHP 中间件 "
           href="/2022/11/05/PHP-RabbitMQ-1%E5%9F%BA%E7%A1%80/"
           data-tag="PHP,RabbitMQ"
           data-author="" >
            <span class="post-title" title="PHP-RabbitMQ-1基础">PHP-RabbitMQ-1基础</span>
            <span class="post-date" title="2022-11-05 00:00:00">2022/11/05</span>
        </a>
        
        
        <a  class="全部文章 运维 "
           href="/2022/10/22/Jmeter/"
           data-tag="运维,Jmeter"
           data-author="" >
            <span class="post-title" title="Jemter压测工具安装使用总结">Jemter压测工具安装使用总结</span>
            <span class="post-date" title="2022-10-22 00:00:00">2022/10/22</span>
        </a>
        
        
        <a  class="全部文章 游戏 "
           href="/2022/10/10/CocosCreator03/"
           data-tag="游戏,Cocos"
           data-author="" >
            <span class="post-title" title="CocosCreator03">CocosCreator03</span>
            <span class="post-date" title="2022-10-10 00:00:00">2022/10/10</span>
        </a>
        
        
        <a  class="全部文章 游戏 "
           href="/2022/10/06/CocosCreator02/"
           data-tag="游戏,Cocos"
           data-author="" >
            <span class="post-title" title="CocosCreator02">CocosCreator02</span>
            <span class="post-date" title="2022-10-06 00:00:00">2022/10/06</span>
        </a>
        
        
        <a  class="全部文章 游戏 "
           href="/2022/10/03/CocosCreator01/"
           data-tag="游戏,Cocos"
           data-author="" >
            <span class="post-title" title="CocosCreator01">CocosCreator01</span>
            <span class="post-date" title="2022-10-03 00:00:00">2022/10/03</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue "
           href="/2022/08/13/Vuex/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="Vuex">Vuex</span>
            <span class="post-date" title="2022-08-13 00:00:00">2022/08/13</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue "
           href="/2022/08/12/VueCLI/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="Vue CLI">Vue CLI</span>
            <span class="post-date" title="2022-08-12 00:00:00">2022/08/12</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue "
           href="/2022/08/11/Vue-%E6%A0%B8%E5%BF%83/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="Vue-核心">Vue-核心</span>
            <span class="post-date" title="2022-08-11 00:00:00">2022/08/11</span>
        </a>
        
        
        <a  class="全部文章 前端 ES6 "
           href="/2022/08/10/ECMAScript6(3)/"
           data-tag="前端,JS,ES6"
           data-author="" >
            <span class="post-title" title="ECMAScript6(3)">ECMAScript6(3)</span>
            <span class="post-date" title="2022-08-10 00:00:00">2022/08/10</span>
        </a>
        
        
        <a  class="全部文章 前端 ES6 "
           href="/2022/08/09/ECMAScript6(2)/"
           data-tag="前端,JS,ES6"
           data-author="" >
            <span class="post-title" title="ECMAScript6(2)">ECMAScript6(2)</span>
            <span class="post-date" title="2022-08-09 00:00:00">2022/08/09</span>
        </a>
        
        
        <a  class="全部文章 前端 ES6 "
           href="/2022/08/08/ECMAScript6(1)/"
           data-tag="前端,JS,ES6"
           data-author="" >
            <span class="post-title" title="ECMAScript6(1)">ECMAScript6(1)</span>
            <span class="post-date" title="2022-08-08 00:00:00">2022/08/08</span>
        </a>
        
        
        <a  class="全部文章 前端 JS "
           href="/2022/08/07/JavaScript%E5%9F%BA%E7%A1%801/"
           data-tag="前端,JavaScript"
           data-author="" >
            <span class="post-title" title="JavaScript基础1">JavaScript基础1</span>
            <span class="post-date" title="2022-08-07 00:00:00">2022/08/07</span>
        </a>
        
        
        <a  class="全部文章 前端 JS "
           href="/2022/08/07/JavaScript%E5%9F%BA%E7%A1%802/"
           data-tag="前端,JavaScript"
           data-author="" >
            <span class="post-title" title="JavaScript基础2">JavaScript基础2</span>
            <span class="post-date" title="2022-08-07 00:00:00">2022/08/07</span>
        </a>
        
        
        <a  class="全部文章 前端 HTML "
           href="/2022/08/06/%E7%A7%BB%E5%8A%A8Web%E5%B8%83%E5%B1%802/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="移动Web布局2">移动Web布局2</span>
            <span class="post-date" title="2022-08-06 00:00:00">2022/08/06</span>
        </a>
        
        
        <a  class="全部文章 前端 HTML "
           href="/2022/08/05/%E7%A7%BB%E5%8A%A8Web%E5%B8%83%E5%B1%801/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="移动Web布局1">移动Web布局1</span>
            <span class="post-date" title="2022-08-05 00:00:00">2022/08/05</span>
        </a>
        
        
        <a  class="全部文章 前端 HTML "
           href="/2022/08/04/HTML5&CSS3/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="HTML5&amp;CSS3">HTML5&amp;CSS3</span>
            <span class="post-date" title="2022-08-04 00:00:00">2022/08/04</span>
        </a>
        
        
        <a  class="全部文章 前端 CSS "
           href="/2022/08/03/CSS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%9302/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="CSS基础总结02">CSS基础总结02</span>
            <span class="post-date" title="2022-08-03 00:00:00">2022/08/03</span>
        </a>
        
        
        <a  class="全部文章 前端 CSS "
           href="/2022/08/02/CSS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%9301/"
           data-tag="前端,CSS"
           data-author="" >
            <span class="post-title" title="CSS基础总结01">CSS基础总结01</span>
            <span class="post-date" title="2022-08-02 00:00:00">2022/08/02</span>
        </a>
        
        
        <a  class="全部文章 前端 HTML "
           href="/2022/08/01/HTML%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"
           data-tag="前端,HTML"
           data-author="" >
            <span class="post-title" title="HTML基础总结">HTML基础总结</span>
            <span class="post-date" title="2022-08-01 00:00:00">2022/08/01</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/08/01/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang11-panic%E5%92%8Crevocer/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang11-panic和revocer">幼麟实验室Golang11-panic和revocer</span>
            <span class="post-date" title="2022-08-01 00:00:00">2022/08/01</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/07/29/Redis%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis底层设计与源码分析">Redis底层设计与源码分析</span>
            <span class="post-date" title="2022-07-29 00:00:00">2022/07/29</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/29/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang09-defer/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang09-defer">幼麟实验室Golang09-defer</span>
            <span class="post-date" title="2022-07-29 00:00:00">2022/07/29</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/28/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang08-%E6%96%B9%E6%B3%95/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang08-方法">幼麟实验室Golang08-方法</span>
            <span class="post-date" title="2022-07-28 00:00:00">2022/07/28</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/27/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang07-%E9%97%AD%E5%8C%85/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang07-闭包">幼麟实验室Golang07-闭包</span>
            <span class="post-date" title="2022-07-27 00:00:00">2022/07/27</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/26/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang06-%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang06-传参和返回值">幼麟实验室Golang06-传参和返回值</span>
            <span class="post-date" title="2022-07-26 00:00:00">2022/07/26</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/25/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang05-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang05-函数调用栈">幼麟实验室Golang05-函数调用栈</span>
            <span class="post-date" title="2022-07-25 00:00:00">2022/07/25</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/24/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang04-map/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang04-map">幼麟实验室Golang04-map</span>
            <span class="post-date" title="2022-07-24 00:00:00">2022/07/24</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/23/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang03-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang03-内存对齐">幼麟实验室Golang03-内存对齐</span>
            <span class="post-date" title="2022-07-23 00:00:00">2022/07/23</span>
        </a>
        
        
        <a  class="全部文章 PHP 基础 "
           href="/2022/07/22/PHP5-8%E5%90%84%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"
           data-tag="后端,PHP"
           data-author="" >
            <span class="post-title" title="PHP5-8各版本特性详解">PHP5-8各版本特性详解</span>
            <span class="post-date" title="2022-07-22 00:00:00">2022/07/22</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/22/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang02-slice/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang02-slice">幼麟实验室Golang02-slice</span>
            <span class="post-date" title="2022-07-22 00:00:00">2022/07/22</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/07/21/%E5%B9%BC%E9%BA%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4Golang01-string/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="幼麟实验室Golang01-string">幼麟实验室Golang01-string</span>
            <span class="post-date" title="2022-07-21 00:00:00">2022/07/21</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/15/K8S%E6%9E%B6%E6%9E%84%E5%B8%8815/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="15中间件容器化-Helm">15中间件容器化-Helm</span>
            <span class="post-date" title="2022-07-15 00:00:00">2022/07/15</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/14/K8S%E6%9E%B6%E6%9E%84%E5%B8%8814/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="14云原生存储">14云原生存储</span>
            <span class="post-date" title="2022-07-14 00:00:00">2022/07/14</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/13/K8S%E6%9E%B6%E6%9E%84%E5%B8%8813/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="13权限控制">13权限控制</span>
            <span class="post-date" title="2022-07-13 00:00:00">2022/07/13</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/12/K8S%E6%9E%B6%E6%9E%84%E5%B8%8812/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="12资源配额">12资源配额</span>
            <span class="post-date" title="2022-07-12 00:00:00">2022/07/12</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/11/K8S%E6%9E%B6%E6%9E%84%E5%B8%8811/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="11计划任务-污点-亲和力">11计划任务-污点-亲和力</span>
            <span class="post-date" title="2022-07-11 00:00:00">2022/07/11</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/09/K8S%E6%9E%B6%E6%9E%84%E5%B8%8809/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="09配置管理">09配置管理</span>
            <span class="post-date" title="2022-07-09 00:00:00">2022/07/09</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/09/K8S%E6%9E%B6%E6%9E%84%E5%B8%8810/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="10持久化存储">10持久化存储</span>
            <span class="post-date" title="2022-07-09 00:00:00">2022/07/09</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/08/K8S%E6%9E%B6%E6%9E%84%E5%B8%8808/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="08服务发布">08服务发布</span>
            <span class="post-date" title="2022-07-08 00:00:00">2022/07/08</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/07/K8S%E6%9E%B6%E6%9E%84%E5%B8%8807/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="07资源调度">07资源调度</span>
            <span class="post-date" title="2022-07-07 00:00:00">2022/07/07</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/06/K8S%E6%9E%B6%E6%9E%84%E5%B8%8806/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="06基本概念">06基本概念</span>
            <span class="post-date" title="2022-07-06 00:00:00">2022/07/06</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/05/K8S%E6%9E%B6%E6%9E%84%E5%B8%8805/"
           data-tag="K8S,Docker"
           data-author="" >
            <span class="post-title" title="05容器基础">05容器基础</span>
            <span class="post-date" title="2022-07-05 00:00:00">2022/07/05</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/03/K8S%E6%9E%B6%E6%9E%84%E5%B8%8803/"
           data-tag="K8S"
           data-author="" >
            <span class="post-title" title="03Kubeadm高可用集群下">03Kubeadm高可用集群下</span>
            <span class="post-date" title="2022-07-03 00:00:00">2022/07/03</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/03/K8S%E6%9E%B6%E6%9E%84%E5%B8%8804/"
           data-tag="K8S"
           data-author="" >
            <span class="post-title" title="04二进制高可用集群">04二进制高可用集群</span>
            <span class="post-date" title="2022-07-03 00:00:00">2022/07/03</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/02/K8S%E6%9E%B6%E6%9E%84%E5%B8%8802/"
           data-tag="K8S"
           data-author="" >
            <span class="post-title" title="02Kubeadm高可用集群上">02Kubeadm高可用集群上</span>
            <span class="post-date" title="2022-07-02 00:00:00">2022/07/02</span>
        </a>
        
        
        <a  class="全部文章 英语 语法 "
           href="/2022/07/02/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%9502%E8%AF%8D%E6%80%A7/"
           data-tag="英语,语法"
           data-author="" >
            <span class="post-title" title="02词性">02词性</span>
            <span class="post-date" title="2022-07-02 00:00:00">2022/07/02</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S架构师 "
           href="/2022/07/01/K8S%E6%9E%B6%E6%9E%84%E5%B8%8801/"
           data-tag="K8S"
           data-author="" >
            <span class="post-title" title="01准备工作">01准备工作</span>
            <span class="post-date" title="2022-07-01 00:00:00">2022/07/01</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/06/04/GoWeb04-Zap%E6%97%A5%E5%BF%97/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="GoWeb高级04-Zap日志">GoWeb高级04-Zap日志</span>
            <span class="post-date" title="2022-06-04 00:00:00">2022/06/04</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/06/03/GoWeb03-Mysql%E5%92%8CRedis/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="GoWeb高级03-Mysql和Redis">GoWeb高级03-Mysql和Redis</span>
            <span class="post-date" title="2022-06-03 00:00:00">2022/06/03</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/06/02/GoWeb02-Gin%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="GoWeb02-Gin源码解析">GoWeb02-Gin源码解析</span>
            <span class="post-date" title="2022-06-02 00:00:00">2022/06/02</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/06/01/GoWeb01-Gin%E5%9F%BA%E7%A1%80/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="GoWeb01-Gin基础">GoWeb01-Gin基础</span>
            <span class="post-date" title="2022-06-01 00:00:00">2022/06/01</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/05/12/Golang%E7%9A%84GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="Golang的GC回收机制">Golang的GC回收机制</span>
            <span class="post-date" title="2022-05-12 00:00:00">2022/05/12</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/05/11/Golang%E7%9A%84GMP%E8%AF%A6%E8%A7%A3/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="Golang的GMP详解">Golang的GMP详解</span>
            <span class="post-date" title="2022-05-11 00:00:00">2022/05/11</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/05/02/Golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="Golang内存管理">Golang内存管理</span>
            <span class="post-date" title="2022-05-02 00:00:00">2022/05/02</span>
        </a>
        
        
        <a  class="全部文章 K8S "
           href="/2022/04/12/K8S12-%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S12-集群资源监控">K8S12-集群资源监控</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/11/K8S11-NFS%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S11-NFS网络存储">K8S11-NFS网络存储</span>
            <span class="post-date" title="2022-04-11 00:00:00">2022/04/11</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/10/K8S10-Helm/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S10-Helm">K8S10-Helm</span>
            <span class="post-date" title="2022-04-10 00:00:00">2022/04/10</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/09/K8S09-Ingress/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S09-Ingress">K8S09-Ingress</span>
            <span class="post-date" title="2022-04-09 00:00:00">2022/04/09</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/08/K8S08-RBAC/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S08-RBAC">K8S08-RBAC</span>
            <span class="post-date" title="2022-04-08 00:00:00">2022/04/08</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/07/K8S07-Secret-ConfigMap/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S07-Secret-ConfigMap">K8S07-Secret-ConfigMap</span>
            <span class="post-date" title="2022-04-07 00:00:00">2022/04/07</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/06/K8S06-Service-Job/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S06-Service-Job">K8S06-Service-Job</span>
            <span class="post-date" title="2022-04-06 00:00:00">2022/04/06</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/05/K8S05-Controller-Deployment/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S05-Controller-Deployment">K8S05-Controller-Deployment</span>
            <span class="post-date" title="2022-04-05 00:00:00">2022/04/05</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/04/K8S04-POD%E5%92%8CLabel/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S04-POD和Label">K8S04-POD和Label</span>
            <span class="post-date" title="2022-04-04 00:00:00">2022/04/04</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/03/K8S03-YAML/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S03-YAML">K8S03-YAML</span>
            <span class="post-date" title="2022-04-03 00:00:00">2022/04/03</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/02/K8S02-Kubectl/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S02-kubectl">K8S02-kubectl</span>
            <span class="post-date" title="2022-04-02 00:00:00">2022/04/02</span>
        </a>
        
        
        <a  class="全部文章 K8S K8S基础 "
           href="/2022/04/01/K8S01-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/"
           data-tag="K8S,容器"
           data-author="" >
            <span class="post-title" title="K8S01-安装环境">K8S01-安装环境</span>
            <span class="post-date" title="2022-04-01 00:00:00">2022/04/01</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2022/02/22/Golang%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="Golang常见错误">Golang常见错误</span>
            <span class="post-date" title="2022-02-22 00:00:00">2022/02/22</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/13/Redis13-%E6%80%BB%E7%BB%93/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis13-总结">Redis13-总结</span>
            <span class="post-date" title="2022-02-13 00:00:00">2022/02/13</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/12/Redis12-%E6%96%B0%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis12-新功能介绍">Redis12-新功能介绍</span>
            <span class="post-date" title="2022-02-12 00:00:00">2022/02/12</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/11/Redis11-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis11-分布式锁">Redis11-分布式锁</span>
            <span class="post-date" title="2022-02-11 00:00:00">2022/02/11</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/10/Redis10-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%C2%B7%E5%87%BB%E7%A9%BF%C2%B7%E9%9B%AA%E5%B4%A9/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis10-缓存穿透·击穿·雪崩">Redis10-缓存穿透·击穿·雪崩</span>
            <span class="post-date" title="2022-02-10 00:00:00">2022/02/10</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/09/Redis09-%E9%9B%86%E7%BE%A4/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis09-集群">Redis09-集群</span>
            <span class="post-date" title="2022-02-09 00:00:00">2022/02/09</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/08/Redis08-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis08-主从复制">Redis08-主从复制</span>
            <span class="post-date" title="2022-02-08 00:00:00">2022/02/08</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/07/Redis07-%E6%8C%81%E4%B9%85%E5%8C%96/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis07-持久化">Redis07-持久化</span>
            <span class="post-date" title="2022-02-07 00:00:00">2022/02/07</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/06/Redis06-%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E3%80%81%E7%A7%92%E6%9D%80/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis06-事务、锁、秒杀">Redis06-事务、锁、秒杀</span>
            <span class="post-date" title="2022-02-06 00:00:00">2022/02/06</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/05/Redis05-Jedis%E3%80%81SprintBoot%E6%95%B4%E5%90%88Redis/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis05-Jedis、SprintBoot整合Redis">Redis05-Jedis、SprintBoot整合Redis</span>
            <span class="post-date" title="2022-02-05 00:00:00">2022/02/05</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/04/Redis04-%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis04-新数据类型">Redis04-新数据类型</span>
            <span class="post-date" title="2022-02-04 00:00:00">2022/02/04</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/03/Redis03-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis03-配置文件、发布和订阅">Redis03-配置文件、发布和订阅</span>
            <span class="post-date" title="2022-02-03 00:00:00">2022/02/03</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/02/Redis02-%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis02-常用五大数据类型">Redis02-常用五大数据类型</span>
            <span class="post-date" title="2022-02-02 00:00:00">2022/02/02</span>
        </a>
        
        
        <a  class="全部文章 REDIS "
           href="/2022/02/01/Redis01-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%AE%89%E8%A3%85/"
           data-tag="后端,REDIS"
           data-author="" >
            <span class="post-title" title="Redis01-基础及安装">Redis01-基础及安装</span>
            <span class="post-date" title="2022-02-01 00:00:00">2022/02/01</span>
        </a>
        
        
        <a  class="全部文章 JAVA "
           href="/2021/11/25/JavaWeb03-JSP/"
           data-tag="后端,Java"
           data-author="" >
            <span class="post-title" title="JavaWeb03-JSP">JavaWeb03-JSP</span>
            <span class="post-date" title="2021-11-25 00:00:00">2021/11/25</span>
        </a>
        
        
        <a  class="全部文章 JAVA "
           href="/2021/11/22/JavaWeb02-Servlet%E3%80%81Cookie%E3%80%81Session/"
           data-tag="后端,Java"
           data-author="" >
            <span class="post-title" title="JavaWeb02-Servlet、Cookie、Session">JavaWeb02-Servlet、Cookie、Session</span>
            <span class="post-date" title="2021-11-22 00:00:00">2021/11/22</span>
        </a>
        
        
        <a  class="全部文章 JAVA "
           href="/2021/11/21/JavaWeb01-Tomcat%E3%80%81Maven%E9%85%8D%E7%BD%AE/"
           data-tag="后端,Java"
           data-author="" >
            <span class="post-title" title="JavaWeb01-Tomcat、Maven配置">JavaWeb01-Tomcat、Maven配置</span>
            <span class="post-date" title="2021-11-21 00:00:00">2021/11/21</span>
        </a>
        
        
        <a  class="全部文章 JAVA "
           href="/2021/11/15/Java02-JDBC/"
           data-tag="后端,Java"
           data-author="" >
            <span class="post-title" title="Java01-JDBC">Java01-JDBC</span>
            <span class="post-date" title="2021-11-15 00:00:00">2021/11/15</span>
        </a>
        
        
        <a  class="全部文章 JAVA "
           href="/2021/11/14/Java01-JavaSE/"
           data-tag="后端,Java"
           data-author="" >
            <span class="post-title" title="Java01-JavaSE">Java01-JavaSE</span>
            <span class="post-date" title="2021-11-14 00:00:00">2021/11/14</span>
        </a>
        
        
        <a  class="全部文章 PHP Laravel "
           href="/2021/10/04/Laravel%E5%BA%95%E5%B1%8204-%E5%8A%A0%E8%BD%BD%E5%B9%B6%E5%90%AF%E5%8A%A8ServiceProvider/"
           data-tag="后端,PHP,Laravel"
           data-author="" >
            <span class="post-title" title="Laravel底层04-加载并启动ServiceProvider">Laravel底层04-加载并启动ServiceProvider</span>
            <span class="post-date" title="2021-10-04 00:00:00">2021/10/04</span>
        </a>
        
        
        <a  class="全部文章 PHP Laravel "
           href="/2021/10/03/Laravel%E5%BA%95%E5%B1%8203-make%E5%92%8Cbuild/"
           data-tag="后端,PHP,Laravel"
           data-author="" >
            <span class="post-title" title="Laravel底层03-make和build">Laravel底层03-make和build</span>
            <span class="post-date" title="2021-10-03 00:00:00">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 PHP Laravel "
           href="/2021/10/02/Laravel%E5%BA%95%E5%B1%8202-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/"
           data-tag="后端,PHP,Laravel"
           data-author="" >
            <span class="post-title" title="Laravel底层02-服务容器，服务提供者">Laravel底层02-服务容器，服务提供者</span>
            <span class="post-date" title="2021-10-02 00:00:00">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 PHP Laravel "
           href="/2021/10/01/Laravel%E5%BA%95%E5%B1%8201-%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%EF%BC%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%8C%E9%97%AD%E5%8C%85/"
           data-tag="后端,PHP,Laravel"
           data-author="" >
            <span class="post-title" title="Laravel底层01-框架核心，依赖注入，闭包">Laravel底层01-框架核心，依赖注入，闭包</span>
            <span class="post-date" title="2021-10-01 00:00:00">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/08/Docker08-DockerCompose/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker08-DockerCompose">Docker08-DockerCompose</span>
            <span class="post-date" title="2021-08-08 00:00:00">2021/08/08</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/07/Docker07-%E7%BD%91%E7%BB%9C/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker07-网络">Docker07-网络</span>
            <span class="post-date" title="2021-08-07 00:00:00">2021/08/07</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/06/Docker06-%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E5%92%8CDockerfile/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker06-数据卷容器和Dockerfile">Docker06-数据卷容器和Dockerfile</span>
            <span class="post-date" title="2021-08-06 00:00:00">2021/08/06</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/05/Docker05-%E6%95%B0%E6%8D%AE%E6%8C%82%E8%BD%BD/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker05-数据挂载">Docker05-数据挂载</span>
            <span class="post-date" title="2021-08-05 00:00:00">2021/08/05</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/04/Docker04-%E9%95%9C%E5%83%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%8F%90%E4%BA%A4/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker04-镜像的原理和提交">Docker04-镜像的原理和提交</span>
            <span class="post-date" title="2021-08-04 00:00:00">2021/08/04</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/03/Docker03-%E5%AE%89%E8%A3%85Nginx,Elasticsearch,Portainer%E5%8F%AF%E8%A7%86%E5%8C%96/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker03-安装Nginx,Elasticsearch,Portainer可视化">Docker03-安装Nginx,Elasticsearch,Portainer可视化</span>
            <span class="post-date" title="2021-08-03 00:00:00">2021/08/03</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/02/Docker02-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%91%BD%E4%BB%A4/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker02-概念和命令">Docker02-概念和命令</span>
            <span class="post-date" title="2021-08-02 00:00:00">2021/08/02</span>
        </a>
        
        
        <a  class="全部文章 DOCKER "
           href="/2021/08/01/Docker01-%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/"
           data-tag="DOCKER,容器"
           data-author="" >
            <span class="post-title" title="Docker01-安装和卸载">Docker01-安装和卸载</span>
            <span class="post-date" title="2021-08-01 00:00:00">2021/08/01</span>
        </a>
        
        
        <a  class="全部文章 PHP Laravel "
           href="/2021/08/01/Laravel-Swoole%E5%95%86%E5%9F%8E01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"
           data-tag="Swoole,PHP"
           data-author="" >
            <span class="post-title" title="Laravel-Swoole01-环境搭建.md">Laravel-Swoole01-环境搭建.md</span>
            <span class="post-date" title="2021-08-01 00:00:00">2021/08/01</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/11/GOPL11-%E5%8F%8D%E5%B0%84/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL11-反射">GOPL11-反射</span>
            <span class="post-date" title="2021-07-11 00:00:00">2021/07/11</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/10/GOPL10-%E6%B5%8B%E8%AF%95/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL10-测试">GOPL10-测试</span>
            <span class="post-date" title="2021-07-10 00:00:00">2021/07/10</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/09/GOPL09-%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL09-包和工具">GOPL09-包和工具</span>
            <span class="post-date" title="2021-07-09 00:00:00">2021/07/09</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/08/GOPL08-%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL08-基于共享变量的并发">GOPL08-基于共享变量的并发</span>
            <span class="post-date" title="2021-07-08 00:00:00">2021/07/08</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/07/GOPL07-Goroutines%E5%92%8CChannels/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL07-Goroutines和Channels">GOPL07-Goroutines和Channels</span>
            <span class="post-date" title="2021-07-07 00:00:00">2021/07/07</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/06/GOPL06-%E6%8E%A5%E5%8F%A3/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL06-接口">GOPL06-接口</span>
            <span class="post-date" title="2021-07-06 00:00:00">2021/07/06</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/05/GOPL05-%E6%96%B9%E6%B3%95/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL05-方法">GOPL05-方法</span>
            <span class="post-date" title="2021-07-05 00:00:00">2021/07/05</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/04/GOPL04-%E5%87%BD%E6%95%B0/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL04-函数">GOPL04-函数</span>
            <span class="post-date" title="2021-07-04 00:00:00">2021/07/04</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/03/GOPL03-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL03-复合数据类型">GOPL03-复合数据类型</span>
            <span class="post-date" title="2021-07-03 00:00:00">2021/07/03</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/02/GOPL02-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL02-基础数据类型">GOPL02-基础数据类型</span>
            <span class="post-date" title="2021-07-02 00:00:00">2021/07/02</span>
        </a>
        
        
        <a  class="全部文章 GO "
           href="/2021/07/01/GOPL01-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"
           data-tag="GO,GOPL"
           data-author="" >
            <span class="post-title" title="GOPL01-程序结构">GOPL01-程序结构</span>
            <span class="post-date" title="2021-07-01 00:00:00">2021/07/01</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/21/Mysql45%E8%AE%B221-%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲21-加锁规则">Mysql45讲21-加锁规则</span>
            <span class="post-date" title="2021-06-21 00:00:00">2021/06/21</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/20/Mysql45%E8%AE%B220-%E5%B9%BB%E8%AF%BB-%E9%97%B4%E9%9A%99%E9%94%81/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲20-幻读-间隙锁">Mysql45讲20-幻读-间隙锁</span>
            <span class="post-date" title="2021-06-20 00:00:00">2021/06/20</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/19/Mysql45%E8%AE%B219-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲19-问题排查">Mysql45讲19-问题排查</span>
            <span class="post-date" title="2021-06-19 00:00:00">2021/06/19</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/17/Mysql45%E8%AE%B217-18-%E9%9A%8F%E6%9C%BA%E6%9F%A5%E8%AF%A2/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲17-18-随机查询">Mysql45讲17-18-随机查询</span>
            <span class="post-date" title="2021-06-17 00:00:00">2021/06/17</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/06/Mysql45%E8%AE%B206-%E8%AE%A1%E6%95%B0%EF%BC%8C%E6%8E%92%E5%BA%8F/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲06-计数，排序">Mysql45讲06-计数，排序</span>
            <span class="post-date" title="2021-06-06 00:00:00">2021/06/06</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/05/Mysql45%E8%AE%B205-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%88%B7%E7%9B%98/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲05-前缀索引，刷盘">Mysql45讲05-前缀索引，刷盘</span>
            <span class="post-date" title="2021-06-05 00:00:00">2021/06/05</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/04/Mysql45%E8%AE%B204-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲04-普通索引，唯一索引">Mysql45讲04-普通索引，唯一索引</span>
            <span class="post-date" title="2021-06-04 00:00:00">2021/06/04</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/03/Mysql45%E8%AE%B203-%E9%94%81/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲03-锁">Mysql45讲03-锁</span>
            <span class="post-date" title="2021-06-03 00:00:00">2021/06/03</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/02/Mysql45%E8%AE%B202-%E6%97%A5%E5%BF%97/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲02-日志">Mysql45讲02-日志</span>
            <span class="post-date" title="2021-06-02 00:00:00">2021/06/02</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/02/Mysql45%E8%AE%B202-%E4%BA%8B%E5%8A%A1%E5%92%8C%E7%B4%A2%E5%BC%95/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲02-事务和索引">Mysql45讲02-事务和索引</span>
            <span class="post-date" title="2021-06-02 00:00:00">2021/06/02</span>
        </a>
        
        
        <a  class="全部文章 MYSQL "
           href="/2021/06/01/Mysql45%E8%AE%B201-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"
           data-tag="后端,MYSQL"
           data-author="" >
            <span class="post-title" title="Mysql45讲01-基础架构">Mysql45讲01-基础架构</span>
            <span class="post-date" title="2021-06-01 00:00:00">2021/06/01</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/05/18/Go%E9%9D%A2%E8%AF%95%E9%A2%9805/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题05">Go面试题05</span>
            <span class="post-date" title="2021-05-18 00:00:00">2021/05/18</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/05/17/Go%E9%9D%A2%E8%AF%95%E9%A2%9804/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题04">Go面试题04</span>
            <span class="post-date" title="2021-05-17 00:00:00">2021/05/17</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/05/16/Go%E9%9D%A2%E8%AF%95%E9%A2%9803/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题03">Go面试题03</span>
            <span class="post-date" title="2021-05-16 00:00:00">2021/05/16</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/05/15/Go%E9%9D%A2%E8%AF%95%E9%A2%9802/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题02">Go面试题02</span>
            <span class="post-date" title="2021-05-15 00:00:00">2021/05/15</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/05/14/Go%E9%9D%A2%E8%AF%95%E9%A2%9801/"
           data-tag="GO,面试"
           data-author="" >
            <span class="post-title" title="Go面试题01">Go面试题01</span>
            <span class="post-date" title="2021-05-14 00:00:00">2021/05/14</span>
        </a>
        
        
        <a  class="全部文章 WEB "
           href="/2021/05/03/%E9%AB%98%E6%80%A7%E8%83%BDWeb03-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/"
           data-tag="WEB"
           data-author="" >
            <span class="post-title" title="高性能Web03-并发处理">高性能Web03-并发处理</span>
            <span class="post-date" title="2021-05-03 00:00:00">2021/05/03</span>
        </a>
        
        
        <a  class="全部文章 WEB "
           href="/2021/05/02/%E9%AB%98%E6%80%A7%E8%83%BDWeb02-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"
           data-tag="WEB"
           data-author="" >
            <span class="post-title" title="高性能Web02-网络传输">高性能Web02-网络传输</span>
            <span class="post-date" title="2021-05-02 00:00:00">2021/05/02</span>
        </a>
        
        
        <a  class="全部文章 WEB "
           href="/2021/05/01/%E9%AB%98%E6%80%A7%E8%83%BDWeb01-%E7%BB%AA%E8%AE%BA/"
           data-tag="WEB"
           data-author="" >
            <span class="post-title" title="构建高性能Web站点01">构建高性能Web站点01</span>
            <span class="post-date" title="2021-05-01 00:00:00">2021/05/01</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/04/11/Mysql%E9%9D%A2%E8%AF%95%E9%A2%9801/"
           data-tag="面试,Mysql"
           data-author="" >
            <span class="post-title" title="Mysql面试题01">Mysql面试题01</span>
            <span class="post-date" title="2021-04-11 00:00:00">2021/04/11</span>
        </a>
        
        
        <a  class="全部文章 面试 "
           href="/2021/04/01/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag="面试,PHP"
           data-author="" >
            <span class="post-title" title="PHP面试题">PHP面试题</span>
            <span class="post-date" title="2021-04-01 00:00:00">2021/04/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-GOPL06-接口" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">GOPL06-接口</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="GO">GO</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">GO</a>
            
            <a class="color5">GOPL</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-05-27 12:04:41'>2021-07-06 00:00</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%88%E7%BA%A6"><span class="toc-text">接口是合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">接口类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%86%85%E5%B5%8C"><span class="toc-text">接口内嵌</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">实现接口的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E7%BB%86%E8%8A%82"><span class="toc-text">表示细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag-Value%E6%8E%A5%E5%8F%A3"><span class="toc-text">flag.Value接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-text">接口值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC"><span class="toc-text">动态类型和动态值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-text">比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nil%E6%8C%87%E9%92%88%E6%8E%A5%E5%8F%A3"><span class="toc-text">nil指针接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-Interface%E6%8E%A5%E5%8F%A3"><span class="toc-text">sort.Interface接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-Sort"><span class="toc-text">sort.Sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-Reverse"><span class="toc-text">sort.Reverse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%97%E6%8E%92%E5%BA%8F"><span class="toc-text">不同列排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88"><span class="toc-text">切片和函数结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E6%8E%92%E5%BA%8F"><span class="toc-text">多层排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-Handler%E6%8E%A5%E5%8F%A3"><span class="toc-text">http.Handler接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-text">指定参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E6%8E%A5%E5%8F%A3"><span class="toc-text">error接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%99%A8"><span class="toc-text">表达式求值器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Eval"><span class="toc-text">Eval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Check"><span class="toc-text">Check</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">具体类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">接口类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E6%88%90%E5%8A%9F%E7%BB%93%E6%9E%9C"><span class="toc-text">标识成功结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">基于类型断言区别错误类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AF%A2%E9%97%AE%E8%A1%8C%E4%B8%BA"><span class="toc-text">通过类型断言询问行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-WriteString"><span class="toc-text">io.WriteString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fmt-Fprintf"><span class="toc-text">fmt.Fprintf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF"><span class="toc-text">类型分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">switch语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84XML%E8%A7%A3%E7%A0%81"><span class="toc-text">示例: 基于标记的XML解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-text">一些建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%88%E7%BA%A6"><span class="toc-text">接口是合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">接口类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%86%85%E5%B5%8C"><span class="toc-text">接口内嵌</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">实现接口的条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E7%BB%86%E8%8A%82"><span class="toc-text">表示细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag-Value%E6%8E%A5%E5%8F%A3"><span class="toc-text">flag.Value接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-text">接口值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC"><span class="toc-text">动态类型和动态值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-text">比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nil%E6%8C%87%E9%92%88%E6%8E%A5%E5%8F%A3"><span class="toc-text">nil指针接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-Interface%E6%8E%A5%E5%8F%A3"><span class="toc-text">sort.Interface接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-Sort"><span class="toc-text">sort.Sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-Reverse"><span class="toc-text">sort.Reverse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%97%E6%8E%92%E5%BA%8F"><span class="toc-text">不同列排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88"><span class="toc-text">切片和函数结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E6%8E%92%E5%BA%8F"><span class="toc-text">多层排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-Handler%E6%8E%A5%E5%8F%A3"><span class="toc-text">http.Handler接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-text">指定参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E6%8E%A5%E5%8F%A3"><span class="toc-text">error接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%99%A8"><span class="toc-text">表达式求值器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Eval"><span class="toc-text">Eval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Check"><span class="toc-text">Check</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">具体类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">接口类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E6%88%90%E5%8A%9F%E7%BB%93%E6%9E%9C"><span class="toc-text">标识成功结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8C%BA%E5%88%AB%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">基于类型断言区别错误类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AF%A2%E9%97%AE%E8%A1%8C%E4%B8%BA"><span class="toc-text">通过类型断言询问行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-WriteString"><span class="toc-text">io.WriteString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fmt-Fprintf"><span class="toc-text">fmt.Fprintf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF"><span class="toc-text">类型分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">switch语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84XML%E8%A7%A3%E7%A0%81"><span class="toc-text">示例: 基于标记的XML解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-text">一些建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div></p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p>
<p><strong>Go语言中接口类型的独特之处在于它是满足隐式实现的。</strong></p>
<p>没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。</p>
<p>这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。</p>
<h3 id="接口是合约"><a href="#接口是合约" class="headerlink" title="接口是合约"></a>接口是合约</h3><p>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。</p>
<p>当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p>
<p>fmt.Printf，把结果写到标准输出。</p>
<p>fmt.Sprintf，把结果以字符串的形式返回。</p>
<p>这两个函数都使用了另一个函数fmt.Fprintf来进行封装。fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fprintf函数中的第一个是io.Writer类型，这是一个接口类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line">    <span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line">    <span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line">    <span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line">    <span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Implementations must not retain p.</span></span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>io.Writer类型定义了函数Fprintf和这个函数调用者之间的约定。</strong></p>
<p>一方面这个约定需要调用者提供具体类型的值就像<code>*os.File</code>和<code>*bytes.Buffer</code>，这些类型都有一个特定签名和行为的Write的函数。</p>
<p>另一方面这个约定保证了Fprintf接受任何满足io.Writer接口的值都可以工作。</p>
<p><strong>一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）</strong>。这是一个面向对象的特征。</p>
<p>下面<code>*ByteCounter</code>类型里的Write方法，仅仅在丢弃写向它的字节前统计它们的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteCounter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ByteCounter)</span></span> Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    *c += ByteCounter(<span class="built_in">len</span>(p)) <span class="comment">// convert int to ByteCounter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为*ByteCounter满足io.Writer的约定，我们可以把它传入Fprintf函数中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c ByteCounter</span><br><span class="line">c.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Println(c) <span class="comment">// &quot;5&quot;, = len(&quot;hello&quot;)</span></span><br><span class="line">c = <span class="number">0</span>          <span class="comment">// reset the counter</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Dolly&quot;</span></span><br><span class="line">fmt.Fprintf(&amp;c, <span class="string">&quot;hello, %s&quot;</span>, name)</span><br><span class="line">fmt.Println(c) <span class="comment">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p><strong>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</strong></p>
<h5 id="接口内嵌"><a href="#接口内嵌" class="headerlink" title="接口内嵌"></a>接口内嵌</h5><p>io.Writer类型是用得最广泛的接口之一，因为它提供了所有类型的写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。</p>
<p>io包中定义了很多其它有用的接口类型。Reader可以代表任意可以读取bytes的类型，Closer可以是任意可以关闭的值，例如一个文件或是网络链接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些新的接口类型通过组合已有的接口来定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以一个简写命名一个接口，而不用声明它所有的方法，这种方式称为接口内嵌。</strong></p>
<p>不使用内嵌来声明io.ReadWriter接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者甚至使用一种混合的风格：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面3种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。</p>
<h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p><strong>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</strong></p>
<p><code>*os.File</code>类型实现了io.Reader，Writer，Closer，和ReadWriter接口。</p>
<p><code>*bytes.Buffer</code>实现了Reader，Writer，和ReadWriter这些接口，但是它没有实现Closer接口因为它不具有Close方法。</p>
<p>Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，<code>*bytes.Buffer</code>是io.Writer；<code>*os.Files</code>是io.ReadWriter。</p>
<p>接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout           <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)   <span class="comment">// OK: *bytes.Buffer has Write method</span></span><br><span class="line">w = time.Second         <span class="comment">// compile error: time.Duration lacks Write method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwc io.ReadWriteCloser</span><br><span class="line">rwc = os.Stdout         <span class="comment">// OK: *os.File has Read, Write, Close methods</span></span><br><span class="line">rwc = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// compile error: *bytes.Buffer lacks Close method</span></span><br><span class="line"></span><br><span class="line">w = rwc                 <span class="comment">// OK: io.ReadWriteCloser has Write method</span></span><br><span class="line">rwc = w                 <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p>因为ReadWriter和ReadWriteCloser包含有Writer的方法，所以任何实现了ReadWriter和ReadWriteCloser的类型必定也实现了Writer接口</p>
<h4 id="表示细节"><a href="#表示细节" class="headerlink" title="表示细节"></a>表示细节</h4><p>对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个<code>*T</code>的指针。</p>
<p>在T类型的参数上调用一个<code>*T</code>的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。</p>
<p>但这仅仅是一个语法糖：T类型的值不拥有所有<code>*T</code>指针的方法，这样它就可能只实现了更少的接口。</p>
<p>举例：在第6.5章中，IntSet类型的String方法的接收者是一个指针类型，所以我们不能在一个不能寻址的IntSet值上调用这个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*IntSet)</span></span> String() <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> _ = IntSet&#123;&#125;.String() <span class="comment">// compile error: String requires *IntSet receiver</span></span><br></pre></td></tr></table></figure>

<p>但是我们可以在一个IntSet变量上调用这个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s IntSet</span><br><span class="line"><span class="keyword">var</span> _ = s.String() <span class="comment">// OK: s is a variable and &amp;s has a String method</span></span><br></pre></td></tr></table></figure>

<p>然而，由于只有<code>*IntSet</code>类型有String方法，所以也只有<code>*IntSet</code>类型实现了fmt.Stringer接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ fmt.Stringer = &amp;s <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">var</span> _ fmt.Stringer = s  <span class="comment">// compile error: IntSet lacks String method</span></span><br></pre></td></tr></table></figure>

<p>接口类型封装和隐藏具体类型和它的值。</p>
<p>即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">os.Stdout.Close()                <span class="comment">// OK: *os.File has Close method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer <span class="comment">// io.Writer接口 只有 Write 方法</span></span><br><span class="line">w = os.Stdout</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// OK: io.Writer has Write method</span></span><br><span class="line">w.Close()                <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>

<p><strong>空接口类型interface{}对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。</p>
<p>下面的定义在编译期断言一个<code>*bytes.Buffer</code>的值实现了io.Writer接口类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer must satisfy io.Writer</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>) <span class="comment">//nil通过(*bytes.Buffer)(nil)进行显示的转换实现了这个接口</span></span><br></pre></td></tr></table></figure>

<p>非空的接口类型比如io.Writer经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。</p>
<p>一个结构体的指针是非常常见的承载方法的类型。</p>
<p>但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。</p>
<p><strong>一个具体的类型可能实现了很多不相关的接口。</strong></p>
<p>考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Album</span><br><span class="line">Book</span><br><span class="line">Movie</span><br><span class="line">Magazine</span><br><span class="line">Podcast</span><br><span class="line">TVEpisode</span><br><span class="line">Track</span><br></pre></td></tr></table></figure>

<p>我们可以把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Artifact <span class="keyword">interface</span> &#123;</span><br><span class="line">    Title() <span class="type">string</span></span><br><span class="line">    Creators() []<span class="type">string</span></span><br><span class="line">    Created() time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，还有只有movies和TV剧集和屏幕分辨率相关。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Text <span class="keyword">interface</span> &#123;</span><br><span class="line">    Pages() <span class="type">int</span></span><br><span class="line">    Words() <span class="type">int</span></span><br><span class="line">    PageSize() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Audio <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="type">string</span> <span class="comment">// e.g., &quot;MP3&quot;, &quot;WAV&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Video <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="type">string</span> <span class="comment">// e.g., &quot;MP4&quot;, &quot;WMV&quot;</span></span><br><span class="line">    Resolution() (x, y <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们发现我们需要以同样的方式处理Audio和Video，我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Streamer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。</strong></p>
<p>当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p>
<h3 id="flag-Value接口"><a href="#flag-Value接口" class="headerlink" title="flag.Value接口"></a>flag.Value接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> period = flag.Duration(<span class="string">&quot;period&quot;</span>, <span class="number">1</span>*time.Second, <span class="string">&quot;sleep period&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sleeping for %v...&quot;</span>, *period)</span><br><span class="line">    time.Sleep(*period)</span><br><span class="line">    fmt.Println() <span class="comment">//Sleeping for 1s...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，休眠周期是一秒，但是可以通过 -period 这个命令行标记来控制。flag.Duration函数创建一个time.Duration类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和String方法相同的符号排版形式。这种对称设计使得用户交互良好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./sleep -period 50ms</span><br><span class="line">Sleeping for 50ms...</span><br><span class="line">$ ./sleep -period 2m30s</span><br><span class="line">Sleeping for 2m30s...</span><br><span class="line">$ ./sleep -period 1.5h</span><br><span class="line">Sleeping for 1h30m0s...</span><br><span class="line">$ ./sleep -period &quot;1 day&quot;</span><br><span class="line">invalid value &quot;1 day&quot; for flag -period: time: invalid duration 1 day</span><br></pre></td></tr></table></figure>

<h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p>支持自定义类型，需要定义一个满足 flag.Value 接口的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value is the interface to the value stored in a flag.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">    Set(<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。注意celsiusFlag内嵌了一个Celsius类型（§2.5），因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9.0</span>/<span class="number">5.0</span> + <span class="number">32.0</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32.0</span>) * <span class="number">5.0</span> / <span class="number">9.0</span>) &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *celsiusFlag 满足 flag.Vulue 接口</span></span><br><span class="line"><span class="keyword">type</span> celsiusFlag <span class="keyword">struct</span>&#123; Celsius &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *celsiusFlag)</span></span> Set(s <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> unit <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> value <span class="type">float64</span></span><br><span class="line">    fmt.Sscanf(s, <span class="string">&quot;%f%s&quot;</span>, &amp;value, &amp;unit) <span class="comment">// no error check needed</span></span><br><span class="line">    <span class="keyword">switch</span> unit &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>, <span class="string">&quot;°C&quot;</span>:</span><br><span class="line">        f.Celsius = Celsius(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>, <span class="string">&quot;°F&quot;</span>:</span><br><span class="line">        f.Celsius = FToC(Fahrenheit(value))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid temperature %q&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用fmt.Sscanf函数从输入s中解析一个浮点数（value）和一个字符串（unit）。</p>
<p>下面的CelsiusFlag函数将所有逻辑都封装在一起。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CelsiusFlag defines a Celsius flag with the specified name,</span></span><br><span class="line"><span class="comment">// default value, and usage, and returns the address of the flag variable.</span></span><br><span class="line"><span class="comment">// The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CelsiusFlag</span><span class="params">(name <span class="type">string</span>, value Celsius, usage <span class="type">string</span>)</span></span> *Celsius &#123;</span><br><span class="line">    f := celsiusFlag&#123;value&#125;</span><br><span class="line">    flag.CommandLine.Var(&amp;f, name, usage)</span><br><span class="line">    <span class="keyword">return</span> &amp;f.Celsius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回了一个 Celsius 的指针，它指向嵌入在 celsiusFlag 变量 f 中的一个字段。Celsius 字段在标志处理过程中会发生变化（经由Set方法）。</p>
<p>调用 Var 方法可以把这个标志加入到程序的命令行标记集合中，即全局变量 flag.CommandLine。</p>
<p>如果一个程序有非常复杂的命令行接口，那么单个全局变量就不够用了，需要多个类似的变量来支撑。</p>
<p>调用 Var 方法是会把 *celsiusFlag 实参赋给 flag.Value 形参，编译器会在此时检查 *celsiusFlag 类型是否有 flag.Value 所必需的方法。</p>
<p>现在我们可以开始在我们的程序中使用新的标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = tempconv.CelsiusFlag(<span class="string">&quot;temp&quot;</span>, <span class="number">20.0</span>, <span class="string">&quot;the temperature&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是典型的场景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch7/tempflag</span><br><span class="line">$ ./tempflag</span><br><span class="line">20°C</span><br><span class="line">$ ./tempflag -temp -18C</span><br><span class="line">-18°C</span><br><span class="line">$ ./tempflag -temp 212°F</span><br><span class="line">100°C</span><br><span class="line">$ ./tempflag -temp 273.15K</span><br><span class="line">invalid value &quot;273.15K&quot; for flag -temp: invalid temperature &quot;273.15K&quot;</span><br><span class="line">Usage of ./tempflag:</span><br><span class="line">  -temp value</span><br><span class="line">        the temperature (default 20°C)</span><br><span class="line">$ ./tempflag -help</span><br><span class="line">Usage of ./tempflag:</span><br><span class="line">  -temp value</span><br><span class="line">        the temperature (default 20°C)</span><br></pre></td></tr></table></figure>

<h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><h4 id="动态类型和动态值"><a href="#动态类型和动态值" class="headerlink" title="动态类型和动态值"></a>动态类型和动态值</h4><p><strong>接口值由两个部分组成，一个具体的类型和那个类型的值，称为接口的动态类型和动态值。</strong></p>
<p>Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。</p>
<p><strong>提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。</strong>在一个接口值中，类型部分代表与之相关类型的描述符。</p>
<p>下面4个语句中，变量w得到了3个不同的值。（开始和最后的值是相同的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>让我们进一步观察在每一个语句后的w变量的值和动态行为。第一个语句定义了变量w:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br></pre></td></tr></table></figure>

<p>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil。</p>
<p><img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h1pamlnolaj207303q3yf.jpg"></p>
<p><strong>一个接口值基于它的动态类型被描述为空或非空</strong>，所以这是一个空的接口值。</p>
<p>你可以通过使用w==nil或者w!=nil来判断接口值是否为空。</p>
<p>调用一个空接口值上的任意方法都会产生panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br></pre></td></tr></table></figure>

<p>第二个语句将一个<code>*os.File</code>类型的值赋给变量w:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = os.Stdout</span><br></pre></td></tr></table></figure>

<p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。</p>
<p>这个接口值的动态类型被设为<code>*os.File</code>指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针。</p>
<p><img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h1pauxv6ttj20eq032q2u.jpg"></p>
<p>调用一个包含<code>*os.File</code>类型指针的接口值的Write方法，使得<code>(*os.File).Write</code>方法被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。</strong></p>
<p>因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。</p>
<p>这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>第三个语句给接口值赋了一个*bytes.Buffer类型的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针（图7.3）。</p>
<p><img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h1paujttmsj20dr034q2v.jpg"></p>
<p>Write方法的调用也使用了和之前一样的机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// writes &quot;hello&quot; to the bytes.Buffers</span></span><br></pre></td></tr></table></figure>

<p>这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。</p>
<p>最后，第四个语句将nil赋给了接口值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态</p>
<p><strong>一个接口值可以持有任意大的动态值。</strong></p>
<p>例如，表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = time.Now()</span><br></pre></td></tr></table></figure>

<p>不论接口值多大，动态值总是可以容下它。</p>
<p><img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h1pb2ai3rij206203y746.jpg" alt="image-20220428120655027"></p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>接口值可以使用==和!＝来进行比较。</p>
<p><strong>两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。</strong></p>
<p>因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</p>
<p>如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(x == x) <span class="comment">// panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure>

<p>在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。</p>
<p>只能比较你非常确定它们的动态值是可比较类型的接口值。</p>
<p>打印接口值的动态类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;&lt;nil&gt;&quot;</span></span><br><span class="line">w = os.Stdout</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*os.File&quot;</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*bytes.Buffer&quot;</span></span><br></pre></td></tr></table></figure>

<p>在fmt包内部，使用反射来获取接口动态类型的名称。</p>
<h4 id="nil指针接口"><a href="#nil指针接口" class="headerlink" title="nil指针接口"></a>nil指针接口</h4><p><strong>警告：一个包含nil指针的接口不是nil接口</strong></p>
<p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。</p>
<p>思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">    &#125;</span><br><span class="line">    f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...use buf...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...do something...</span></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">    out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当main函数调用函数f时，它给f函数的out参数赋了一个<em>bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是</em>bytes.Buffer，意思就是out变量是<strong>一个包含空指针值的非空接口，防御性检查out!=nil的结果依然是true</strong>。</p>
<p><img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h1pbzk5dmej205r02rmwz.jpg"></p>
<p>*bytes.Buffer类型调用Write方法，尝试去获取缓冲区时会发生panic。</p>
<p>(*bytes.Buffer).Write方法的接收者非空，所以将nil指针赋给这个接口是错误的。</p>
<p>解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf io.Writer</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">    buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">&#125;</span><br><span class="line">f(buf) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a>sort.Interface接口</h3><p>排序操作和字符串格式化一样是很多程序经常使用的操作。</p>
<p>sort包内置的提供了根据一些排序函数来对任何序列排序的功能。</p>
<p>Go语言的sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。</p>
<p>这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p>
<p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是sort.Interface的三个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span> <span class="comment">// i, j are indices of sequence elements</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort-Sort"><a href="#sort-Sort" class="headerlink" title="sort.Sort"></a>sort.Sort</h4><p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以通过像下面这样将一个切片转换为一个StringSlice类型来进行排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(StringSlice(names))</span><br></pre></td></tr></table></figure>

<p>这个转换得到一个相同长度，容量，和基于names数组的切片值；并且这个切片值的类型有三个排序需要的方法。</p>
<p>对字符串切片的排序是很常用的需要，所以sort包提供了StringSlice类型，也提供了Strings函数能让上面这些调用简化成<code>sort.Strings(names)</code>。</p>
<p>下面的变量tracks包含了一个播放列表。每个元素都不是Track本身而是指向它的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Track <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="type">string</span></span><br><span class="line">    Artist <span class="type">string</span></span><br><span class="line">    Album  <span class="type">string</span></span><br><span class="line">    Year   <span class="type">int</span></span><br><span class="line">    Length time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tracks = []*Track&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Delilah&quot;</span>, <span class="string">&quot;From the Roots Up&quot;</span>, <span class="number">2012</span>, length(<span class="string">&quot;3m38s&quot;</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Moby&quot;</span>, <span class="string">&quot;Moby&quot;</span>, <span class="number">1992</span>, length(<span class="string">&quot;3m37s&quot;</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Go Ahead&quot;</span>, <span class="string">&quot;Alicia Keys&quot;</span>, <span class="string">&quot;As I Am&quot;</span>, <span class="number">2007</span>, length(<span class="string">&quot;4m36s&quot;</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Ready 2 Go&quot;</span>, <span class="string">&quot;Martin Solveig&quot;</span>, <span class="string">&quot;Smash&quot;</span>, <span class="number">2011</span>, length(<span class="string">&quot;4m24s&quot;</span>)&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将播放列表打印成一个表格</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTracks</span><span class="params">(tracks []*Track)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> format = <span class="string">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span></span><br><span class="line">    tw := <span class="built_in">new</span>(tabwriter.Writer).Init(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    fmt.Fprintf(tw, format, <span class="string">&quot;Title&quot;</span>, <span class="string">&quot;Artist&quot;</span>, <span class="string">&quot;Album&quot;</span>, <span class="string">&quot;Year&quot;</span>, <span class="string">&quot;Length&quot;</span>)</span><br><span class="line">    fmt.Fprintf(tw, format, <span class="string">&quot;-----&quot;</span>, <span class="string">&quot;------&quot;</span>, <span class="string">&quot;-----&quot;</span>, <span class="string">&quot;----&quot;</span>, <span class="string">&quot;------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tracks &#123;</span><br><span class="line">        fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)</span><br><span class="line">    &#125;</span><br><span class="line">    tw.Flush() <span class="comment">// calculate column widths and print table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能按照Artist字段对播放列表进行排序，我们会像对StringSlice那样定义一个新的带有必须的Len，Less和Swap方法的切片类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byArtist []*Track</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x[i].Artist &lt; x[j].Artist &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span></span> Swap(i, j <span class="type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br></pre></td></tr></table></figure>

<p>为了调用通用的排序程序，我们必须先将tracks转换为新的byArtist类型，它定义了具体的排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(byArtist(tracks))</span><br></pre></td></tr></table></figure>

<p>在按照artist对这个切片进行排序后，printTrack的输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br></pre></td></tr></table></figure>

<p>如果用户第二次请求“按照artist排序”，我们会对tracks进行逆向排序。然而我们不需要定义一个有颠倒Less方法的新类型byReverseArtist，因为sort包中提供了Reverse函数将排序顺序转换成逆序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(byArtist(tracks)))</span><br></pre></td></tr></table></figure>

<p>在按照artist对这个切片进行逆向排序后，printTrack的输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br></pre></td></tr></table></figure>

<h4 id="sort-Reverse"><a href="#sort-Reverse" class="headerlink" title="sort.Reverse"></a>sort.Reverse</h4><p>sort包定义了一个不公开的struct类型reverse，它嵌入了一个sort.Interface。</p>
<p>reverse的Less方法调用了内嵌的sort.Interface值的Less方法，但是通过交换索引的方式使排序结果变成逆序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span>&#123; Interface &#125; <span class="comment">// that is, sort.Interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> r.Interface.Less(j, i) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123; <span class="keyword">return</span> reverse&#123;data&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>reverse的另外两个方法Len和Swap隐式地由原有内嵌的sort.Interface提供。</p>
<p>因为reverse是一个不公开的类型，所以导出函数Reverse返回一个包含原有sort.Interface值的reverse类型实例。</p>
<h4 id="不同列排序"><a href="#不同列排序" class="headerlink" title="不同列排序"></a>不同列排序</h4><p>为了可以按照不同的列进行排序，我们必须定义一个新的类型例如byYear：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byYear []*Track</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x[i].Year &lt; x[j].Year &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span></span> Swap(i, j <span class="type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br></pre></td></tr></table></figure>

<p>在使用sort.Sort(byYear(tracks))按照年对tracks进行排序后，printTrack展示了一个按时间先后顺序的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br></pre></td></tr></table></figure>

<p>Len和Swap方法对于所有的切片类型都有相同的定义。</p>
<h4 id="切片和函数结合"><a href="#切片和函数结合" class="headerlink" title="切片和函数结合"></a>切片和函数结合</h4><p>sort.Interface的具体类型不一定是切片类型；customSort是一个结构体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">    t    []*Track</span><br><span class="line">    less <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x.t) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x.less(x.t[i], x.t[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span></span> Swap(i, j <span class="type">int</span>)    &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</span><br></pre></td></tr></table></figure>

<h4 id="多层排序"><a href="#多层排序" class="headerlink" title="多层排序"></a>多层排序</h4><p>这个排序使用了匿名排序函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(customSort&#123;tracks, <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.Title != y.Title &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Title &lt; y.Title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Year != y.Year &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Year &lt; y.Year</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Length != y.Length &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Length &lt; y.Length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这下面是排序的结果。注意到两个标题是“Go”的track按照标题排序是相同的顺序，但是在按照year排序上更久的那个track优先。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album               Year Length</span><br><span class="line">-----       ------          -----               ---- ------</span><br><span class="line">Go          Moby            Moby                1992 3m37s</span><br><span class="line">Go          Delilah         From the Roots Up   2012 3m38s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am             2007 4m36s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash               2011 4m24s</span><br></pre></td></tr></table></figure>

<p>对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">sort.Ints(values)</span><br><span class="line">fmt.Println(values)                     <span class="comment">// &quot;[1 1 3 4]&quot;</span></span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(values)))</span><br><span class="line">fmt.Println(values)                     <span class="comment">// &quot;[4 3 1 1]&quot;</span></span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了使用方便，sort包为[]int、[]string和[]float64的正常排序提供了特定版本的函数和类型。对于其他类型，例如[]int64或者[]uint，尽管路径也很简单，还是依赖我们自己实现。</p>
<h3 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a>http.Handler接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="type">string</span>, h Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><p>ListenAndServe函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, db))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dollars <span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;$%.2f&quot;</span>, d) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="comment">//给database类型一个ServeHttp方法，这样它可以满足http.Handler接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问 http://localhost:8000</span><br><span class="line">shoes: $50.00</span><br><span class="line">socks: $5.00</span><br></pre></td></tr></table></figure>

<h4 id="指定参数"><a href="#指定参数" class="headerlink" title="指定参数"></a>指定参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/list&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/price&quot;</span>:</span><br><span class="line">        item := req.URL.Query().Get(<span class="string">&quot;item&quot;</span>)</span><br><span class="line">        price, ok := db[item]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;no such item: %q\n&quot;</span>, item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s\n&quot;</span>, price)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;no such page: %s\n&quot;</span>, req.URL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在handler基于URL的路径部分（req.URL.Path）来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用w.WriteHeader(http.StatusNotFound)返回客户端一个HTTP错误；这个检查应该在向w写入任何值前完成。（顺便提一下，http.ResponseWriter是另一个接口。它在io.Writer上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的http.Error函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := fmt.Sprintf(<span class="string">&quot;no such page: %s\n&quot;</span>, req.URL)</span><br><span class="line">http.Error(w, msg, http.StatusNotFound) <span class="comment">// 404</span></span><br></pre></td></tr></table></figure>

<p>/price的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个net/url包中url.Values(§6.2.1)类型的多重映射。然后找到第一个item参数并查找它的价格。如果这个货品没有找到会返回一个错误。</p>
<p>这里是一个和新服务器会话的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch7/http2</span><br><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./http2 &amp;</span><br><span class="line">$ ./fetch http://localhost:8000/list</span><br><span class="line">shoes: $50.00</span><br><span class="line">socks: $5.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=socks</span><br><span class="line">$5.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=shoes</span><br><span class="line">$50.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=hat</span><br><span class="line">no such item: &quot;hat&quot;</span><br><span class="line">$ ./fetch http://localhost:8000/help</span><br><span class="line">no such page: /help</span><br></pre></td></tr></table></figure>

<p>显然我们可以继续向ServeHTTP方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如/images/*.png的URL。因为这些原因，net/http包提供了一个请求多路器ServeMux来简化URL和handlers的联系。一个ServeMux将一批http.Handler聚集到一个单一的http.Handler中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的http.Handler 而不需要考虑它后面的具体类型。</p>
<p>对于更复杂的应用，一些ServeMux可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，就像Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。</p>
<p>在下面的程序中，我们创建一个ServeMux并且使用它将URL和相应处理/list和/price操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用ListenAndServe函数中使用ServeMux为主要的handler。</p>
<p><em>gopl.io/ch7/http3</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, mux))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    item := req.URL.Query().Get(<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    price, ok := db[item]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;no such item: %q\n&quot;</span>, item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;%s\n&quot;</span>, price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们关注这两个注册到handlers上的调用。第一个db.list是一个方法值（§6.4），它是下面这个类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说db.list的调用会援引一个接收者是db的database.list方法。所以db.list是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足http.Handler接口并且不能直接传给mux.Handle。</p>
<p>语句http.HandlerFunc(db.list)是一个转换而非一个函数调用，因为http.HandlerFunc是一个类型。它有如下的定义：</p>
<p><em>net/http</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerFunc显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口http.Handler的方法的函数类型。ServeHTTP方法的行为是调用了它的函数本身。因此HandlerFunc是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足http.Handler接口：一种通过它的list方法，一种通过它的price方法等等。</p>
<p>因为handler通过这种方式注册非常普遍，ServeMux有一个方便的HandleFunc方法，它帮我们简化handler注册代码成这样：</p>
<p><em>gopl.io/ch7/http3a</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mux.HandleFunc(<span class="string">&quot;/list&quot;</span>, db.list)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/price&quot;</span>, db.price)</span><br></pre></td></tr></table></figure>

<p>从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个ServeMux并且再调用一次ListenAndServe（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显式地注册到这个应用的ServeMux实例上会比较麻烦。</p>
<p>所以为了方便，net/http包提供了一个全局的ServeMux实例DefaultServerMux和包级别的http.Handle和http.HandleFunc函数。现在，为了使用DefaultServeMux作为服务器的主handler，我们不需要将它传给ListenAndServe函数；nil值就可以工作。</p>
<p>然后服务器的主函数可以简化成：</p>
<p><em>gopl.io/ch7/http4</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/list&quot;</span>, db.list)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/price&quot;</span>, db.price)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，一个重要的提示：就像我们在1.7节中提到的，web服务器在一个新的协程中调用每一个handler，所以<strong>当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。</strong></p>
<h3 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。</p>
<p>整个errors包仅只有4行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="type">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.text &#125;</span><br></pre></td></tr></table></figure>

<p>承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。</p>
<p>并且因为是指针类型<code>*errorString</code>满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。</p>
<p>我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(errors.New(<span class="string">&quot;EOF&quot;</span>) == errors.New(<span class="string">&quot;EOF&quot;</span>)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>syscall包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syscall</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Errno <span class="type">uintptr</span> <span class="comment">// operating system error code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errors = [...]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="number">1</span>:   <span class="string">&quot;operation not permitted&quot;</span>,   <span class="comment">// EPERM</span></span><br><span class="line">    <span class="number">2</span>:   <span class="string">&quot;no such file or directory&quot;</span>, <span class="comment">// ENOENT</span></span><br><span class="line">    <span class="number">3</span>:   <span class="string">&quot;no such process&quot;</span>,           <span class="comment">// ESRCH</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Errno)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt;= <span class="type">int</span>(e) &amp;&amp; <span class="type">int</span>(e) &lt; <span class="built_in">len</span>(errors) &#123;</span><br><span class="line">        <span class="keyword">return</span> errors[e]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;errno %d&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的语句创建了一个持有Errno值为2的接口值，表示POSIX ENOENT状况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span> = syscall.Errno(<span class="number">2</span>)</span><br><span class="line">fmt.Println(err.Error()) <span class="comment">// &quot;no such file or directory&quot;</span></span><br><span class="line">fmt.Println(err)         <span class="comment">// &quot;no such file or directory&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h1pgvv3m6dj206u03amwz.jpg"></p>
<p>Errno是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。</p>
<h3 id="表达式求值器"><a href="#表达式求值器" class="headerlink" title="表达式求值器"></a>表达式求值器</h3><p>我们将使用一个接口Expr来表示Go语言中任意的表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Expr is an arithmetic expression.</span></span><br><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面的五个具体类型表示了具体的表达式类型。Var类型表示对一个变量的引用。（我们很快会知道为什么它可以被输出。）literal类型表示一个浮点型常量。unary和binary类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。call类型表示对一个函数的调用；我们限制它的fn字段只能是pow，sin或者sqrt。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Var identifies a variable, e.g., x.</span></span><br><span class="line"><span class="keyword">type</span> Var <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A literal is a numeric constant, e.g., 3.141.</span></span><br><span class="line"><span class="keyword">type</span> literal <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A unary represents a unary operator expression, e.g., -x.</span></span><br><span class="line"><span class="keyword">type</span> unary <span class="keyword">struct</span> &#123;</span><br><span class="line">    op <span class="type">rune</span> <span class="comment">// one of &#x27;+&#x27;, &#x27;-&#x27;</span></span><br><span class="line">    x  Expr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A binary represents a binary operator expression, e.g., x+y.</span></span><br><span class="line"><span class="keyword">type</span> binary <span class="keyword">struct</span> &#123;</span><br><span class="line">    op   <span class="type">rune</span> <span class="comment">// one of &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;</span></span><br><span class="line">    x, y Expr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A call represents a function call expression, e.g., sin(x).</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    fn   <span class="type">string</span> <span class="comment">// one of &quot;pow&quot;, &quot;sin&quot;, &quot;sqrt&quot;</span></span><br><span class="line">    args []Expr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了计算一个包含变量的表达式，我们需要一个environment变量将变量的名字映射成对应的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Env <span class="keyword">map</span>[Var]<span class="type">float64</span></span><br></pre></td></tr></table></figure>

<h4 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h4><p>我们也需要每个表达式去定义一个Eval方法，这个方法会根据给定的environment变量返回表达式的值。因为每个表达式都必须提供这个方法，我们将它加入到Expr接口中。这个包只会对外公开Expr，Env，和Var类型。调用方不需要获取其它的表达式类型就可以使用这个求值器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Eval returns the value of this Expr in the environment env.</span></span><br><span class="line">    Eval(env Env) <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给大家展示一个具体的Eval方法。Var类型的这个方法对一个environment变量进行查找，如果这个变量没有在environment中定义过这个方法会返回一个零值，literal类型的这个方法简单的返回它真实的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Var)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> env[v]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l literal)</span></span> Eval(_ Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unary和binary的Eval方法会递归的计算它的运算对象，然后将运算符op作用到它们上。我们不将被零或无穷数除作为一个错误，因为它们都会产生一个固定的结果——无限。最后，call的这个方法会计算对于pow，sin，或者sqrt函数的参数值，然后调用对应在math包中的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unary)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> u.op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> +u.x.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> -u.x.Eval(env)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unsupported unary operator: %q&quot;</span>, u.op))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b binary)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> b.op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) + b.y.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) - b.y.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) * b.y.Eval(env)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b.x.Eval(env) / b.y.Eval(env)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unsupported binary operator: %q&quot;</span>, b.op))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c call)</span></span> Eval(env Env) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c.fn &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pow&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> math.Pow(c.args[<span class="number">0</span>].Eval(env), c.args[<span class="number">1</span>].Eval(env))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;sin&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> math.Sin(c.args[<span class="number">0</span>].Eval(env))</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;sqrt&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(c.args[<span class="number">0</span>].Eval(env))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unsupported function call: %s&quot;</span>, c.fn))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些方法会失败。例如，一个call表达式可能有未知的函数或者错误的参数个数。用一个无效的运算符如!或者&lt;去构建一个unary或者binary表达式也是可能会发生的（尽管下面提到的Parse函数不会这样做）。这些错误会让Eval方法panic。其它的错误，像计算一个没有在environment变量中出现过的Var，只会让Eval方法返回一个错误的结果。所有的这些错误都可以通过在计算前检查Expr来发现。这是我们接下来要讲的Check方法的工作，但是让我们先测试Eval方法。</p>
<p>下面的TestEval函数是对evaluator的一个测试。它使用了我们会在第11章讲解的testing包，但是现在知道调用t.Errof会报告一个错误就足够了。这个函数循环遍历一个表格中的输入，这个表格中定义了三个表达式和针对每个表达式不同的环境变量。第一个表达式根据给定圆的面积A计算它的半径，第二个表达式通过两个变量x和y计算两个立方体的体积之和，第三个表达式将华氏温度F转换成摄氏度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEval</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        expr <span class="type">string</span></span><br><span class="line">        env  Env</span><br><span class="line">        want <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="string">&quot;A&quot;</span>: <span class="number">87616</span>, <span class="string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="string">&quot;167&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="string">&quot;x&quot;</span>: <span class="number">12</span>, <span class="string">&quot;y&quot;</span>: <span class="number">1</span>&#125;, <span class="string">&quot;1729&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="string">&quot;x&quot;</span>: <span class="number">9</span>, <span class="string">&quot;y&quot;</span>: <span class="number">10</span>&#125;, <span class="string">&quot;1729&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">-40</span>&#125;, <span class="string">&quot;-40&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">32</span>&#125;, <span class="string">&quot;0&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="string">&quot;F&quot;</span>: <span class="number">212</span>&#125;, <span class="string">&quot;100&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> prevExpr <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        <span class="comment">// Print expr only when it changes.</span></span><br><span class="line">        <span class="keyword">if</span> test.expr != prevExpr &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;\n%s\n&quot;</span>, test.expr)</span><br><span class="line">            prevExpr = test.expr</span><br><span class="line">        &#125;</span><br><span class="line">        expr, err := Parse(test.expr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Error(err) <span class="comment">// parse error</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        got := fmt.Sprintf(<span class="string">&quot;%.6g&quot;</span>, expr.Eval(test.env))</span><br><span class="line">        fmt.Printf(<span class="string">&quot;\t%v =&gt; %s\n&quot;</span>, test.env, got)</span><br><span class="line">        <span class="keyword">if</span> got != test.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;%s.Eval() in %v = %q, want %q\n&quot;</span>,</span><br><span class="line">            test.expr, test.env, got, test.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于表格中的每一条记录，这个测试会解析它的表达式然后在环境变量中计算它，输出结果。这里我们没有空间来展示Parse函数，但是如果你使用go get下载这个包你就可以看到这个函数。</p>
<p>go test(§11.1) 命令会运行一个包的测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v gopl.io/ch7/eval</span><br></pre></td></tr></table></figure>

<p><strong>-v标识可以让我们看到测试用例打印的输出；正常情况下像这样一个成功的测试用例会阻止打印结果的输出。</strong>这里是测试用例里fmt.Printf语句的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">    map[A:87616 pi:3.141592653589793] =&gt; 167</span><br><span class="line"></span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">    map[x:12 y:1] =&gt; 1729</span><br><span class="line">    map[x:9 y:10] =&gt; 1729</span><br><span class="line"></span><br><span class="line">5 / 9 * (F - 32)</span><br><span class="line">    map[F:-40] =&gt; -40</span><br><span class="line">    map[F:32] =&gt; 0</span><br><span class="line">    map[F:212] =&gt; 100</span><br></pre></td></tr></table></figure>

<p>幸运的是目前为止所有的输入都是适合的格式，但是我们的运气不可能一直都有。甚至在解释型语言中，为了静态错误检查语法是非常常见的；<strong>静态错误就是不用运行程序就可以检测出来的错误。</strong></p>
<p>通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。</p>
<h4 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h4><p>Check方法对一个表达式语义树检查出静态错误。我们马上会说明它的vars参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span> &#123;</span><br><span class="line">    Eval(env Env) <span class="type">float64</span></span><br><span class="line">    <span class="comment">// Check reports errors in this Expr and adds its Vars to the set.</span></span><br><span class="line">    Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的Check方法展示在下面。literal和Var类型的计算不可能失败，所以这些类型的Check方法会返回一个nil值。对于unary和binary的Check方法会首先检查操作符是否有效，然后递归的检查运算单元。相似地对于call的这个方法首先检查调用的函数是否已知并且有没有正确个数的参数，然后递归的检查每一个参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Var)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    vars[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(literal)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unary)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.ContainsRune(<span class="string">&quot;+-&quot;</span>, u.op) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unexpected unary op %q&quot;</span>, u.op)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u.x.Check(vars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b binary)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.ContainsRune(<span class="string">&quot;+-*/&quot;</span>, b.op) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unexpected binary op %q&quot;</span>, b.op)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := b.x.Check(vars); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.y.Check(vars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c call)</span></span> Check(vars <span class="keyword">map</span>[Var]<span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    arity, ok := numParams[c.fn]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unknown function %q&quot;</span>, c.fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c.args) != arity &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;call to %s has %d args, want %d&quot;</span>,</span><br><span class="line">            c.fn, <span class="built_in">len</span>(c.args), arity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> c.args &#123;</span><br><span class="line">        <span class="keyword">if</span> err := arg.Check(vars); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numParams = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;pow&quot;</span>: <span class="number">2</span>, <span class="string">&quot;sin&quot;</span>: <span class="number">1</span>, <span class="string">&quot;sqrt&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们在两个组中有选择地列出有问题的输入和它们得出的错误。Parse函数（这里没有出现）会报出一个语法错误和Check函数会报出语义错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x % 2               unexpected &#x27;%&#x27;</span><br><span class="line">math.Pi             unexpected &#x27;.&#x27;</span><br><span class="line">!true               unexpected &#x27;!&#x27;</span><br><span class="line">&quot;hello&quot;             unexpected &#x27;&quot;&#x27;</span><br><span class="line"></span><br><span class="line">log(10)             unknown function &quot;log&quot;</span><br><span class="line">sqrt(1, 2)          call to sqrt has 2 args, want 1</span><br></pre></td></tr></table></figure>

<p>Check方法的参数是一个Var类型的集合，这个集合聚集从表达式中找到的变量名。为了保证成功的计算，这些变量中的每一个都必须出现在环境变量中。从逻辑上讲，这个集合就是调用Check方法返回的结果，但是因为这个方法是递归调用的，所以对于Check方法，填充结果到一个作为参数传入的集合中会更加的方便。调用方在初始调用时必须提供一个空的集合。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p><strong>类型断言是一个使用在接口值上的操作。</strong></p>
<p>x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。</p>
<p><strong>一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</strong></p>
<h4 id="具体类型"><a href="#具体类型" class="headerlink" title="具体类型"></a>具体类型</h4><p>如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。</p>
<p>如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。</p>
<p>换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)      <span class="comment">// success: f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic: interface holds *os.File, not *bytes.Buffer</span></span><br></pre></td></tr></table></figure>

<h4 id="接口类型-1"><a href="#接口类型-1" class="headerlink" title="接口类型"></a>接口类型</h4><p>类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。</p>
<p>如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。</p>
<p>换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。</p>
<p>在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型<code>*os.File</code>，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// success: *os.File has both Read and Write</span></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) <span class="comment">// panic: *ByteCounter has no Read method</span></span><br></pre></td></tr></table></figure>

<p><strong>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。</strong></p>
<p>我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = rw             <span class="comment">// io.ReadWriter is assignable to io.Writer</span></span><br><span class="line">w = rw.(io.Writer) <span class="comment">// fails only if rw == nil</span></span><br></pre></td></tr></table></figure>

<h4 id="标识成功结果"><a href="#标识成功结果" class="headerlink" title="标识成功结果"></a>标识成功结果</h4><p>经常地，对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。</p>
<p>如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File)      <span class="comment">// success:  ok, f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer) <span class="comment">// failure: !ok, b == nil</span></span><br></pre></td></tr></table></figure>

<p>第二个结果通常赋值给一个命名为ok的变量。</p>
<p><strong>如果这个操作失败了，那么ok就是false值，第一个结果等于被断言类型的零值</strong>，在这个例子中就是一个nil的<code>*bytes.Buffer</code>类型。</p>
<p>这个ok结果经常立即用于决定程序下面做什么。if语句的扩展格式让这个变的很简洁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use f...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名。</p>
<p>这个重用的变量原来的值会被覆盖（理解：<strong>其实是声明了一个同名的新的本地变量，外层原来的w不会被改变</strong>），如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> w, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use w...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于类型断言区别错误类型"><a href="#基于类型断言区别错误类型" class="headerlink" title="基于类型断言区别错误类型"></a>基于类型断言区别错误类型</h3><p>在os包中文件操作返回的错误集合。</p>
<p>I/O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。os包中提供了三个帮助函数来对给定的错误值表示的失败进行分类：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>可靠的方式是使用一个专门的类型来描述结构化的错误。</p>
<p>os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op   <span class="type">string</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err := os.Open(<span class="string">&quot;/no/such/file&quot;</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// &quot;open /no/such/file: No such file or directory&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, err)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/file&quot;, Err:0x2&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就是三个帮助函数是怎么工作的。例如下面展示的IsNotExist，它会报出是否一个错误和syscall.ENOENT（§7.8）或者和有名的错误os.ErrNotExist相等（可以在§5.4.2中找到io.EOF）；或者是一个<code>*PathError</code>，它内部的错误是syscall.ENOENT和os.ErrNotExist其中之一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNotExist = errors.New(<span class="string">&quot;file does not exist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsNotExist returns a boolean indicating whether the error is known to</span></span><br><span class="line"><span class="comment">// report that a file or directory does not exist. It is satisfied by</span></span><br><span class="line"><span class="comment">// ErrNotExist as well as some syscall errors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pe, ok := err.(*PathError); ok &#123;</span><br><span class="line">        err = pe.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err == syscall.ENOENT || err == ErrNotExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这里是它的实际使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err := os.Open(<span class="string">&quot;/no/such/file&quot;</span>)</span><br><span class="line">fmt.Println(os.IsNotExist(err)) <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果错误消息结合成一个更大的字符串，当然PathError的结构就不再为人所知，例如通过一个对fmt.Errorf函数的调用。区别错误通常必须在失败操作后，错误传回调用者前进行。</p>
<h3 id="通过类型断言询问行为"><a href="#通过类型断言询问行为" class="headerlink" title="通过类型断言询问行为"></a>通过类型断言询问行为</h3><h4 id="io-WriteString"><a href="#io-WriteString" class="headerlink" title="io.WriteString"></a>io.WriteString</h4><p>下面这段逻辑和net/http包中web服务器负责写入HTTP头字段（例如：”Content-type:text/html”）的部分相似。io.Writer接口类型的变量w代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeader</span><span class="params">(w io.Writer, contentType <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write([]<span class="type">byte</span>(<span class="string">&quot;Content-Type: &quot;</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write([]<span class="type">byte</span>(contentType)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Write方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用[]byte(…)进行转换。</p>
<p>这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。</p>
<p>让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？</p>
<p>在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法；这个方法会避免去分配一个临时的拷贝。</p>
<p>我们可以定义一个只有WriteString方法的新接口并且使用类型断言来检测是否w的动态类型满足这个新接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writeString writes s to w.</span></span><br><span class="line"><span class="comment">// If w has a WriteString method, it is invoked instead of w.Write.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w io.Writer, s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> stringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteString(<span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sw, ok := w.(stringWriter); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sw.WriteString(s) <span class="comment">// avoid a copy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w.Write([]<span class="type">byte</span>(s)) <span class="comment">// allocate temporary copy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeader</span><span class="params">(w io.Writer, contentType <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := writeString(w, <span class="string">&quot;Content-Type: &quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := writeString(w, contentType); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免重复定义，我们将这个检查移入到一个实用工具函数writeString中，但是它太有用了以致于标准库将它作为io.WriteString函数提供。这是向一个io.Writer接口写入字符串的推荐方法。</p>
<p>这个例子的神奇之处在于，没有定义了WriteString方法的标准接口，也没有指定它是一个所需行为的标准接口。</p>
<p>一个具体类型只会通过它的方法决定它是否满足stringWriter接口，而不是任何它和这个接口类型所表达的关系。</p>
<p>它的意思就是上面的技术依赖于一个假设，这个假设就是：如果一个类型满足下面的这个接口，然后WriteString(s)方法就必须和Write([]byte(s))有相同的效果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> &#123;</span><br><span class="line">    io.Writer</span><br><span class="line">    WriteString(s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>writeString函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。</p>
<p>这个技术可以被很好的使用，不论这个被询问的接口是一个标准如io.ReadWriter，或者用户定义的如stringWriter接口。</p>
<h4 id="fmt-Fprintf"><a href="#fmt-Fprintf" class="headerlink" title="fmt.Fprintf"></a>fmt.Fprintf</h4><p>fmt.Fprintf函数怎么从其它所有值中区分满足error或者fmt.Stringer接口的值。在fmt.Fprintf内部，有一个将单个操作对象转换成一个字符串的步骤，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatOneValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err, ok := x.(<span class="type">error</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> err.Error()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> str, ok := x.(Stringer); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> str.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...all other types...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果x满足这两个接口类型中的一个，具体满足的接口决定对值的格式化方式。</p>
<p>任何有String方法的类型都满足fmt.Stringer中约定的行为，这个行为会返回一个适合打印的字符串。</p>
<h3 id="类型分支"><a href="#类型分支" class="headerlink" title="类型分支"></a>类型分支</h3><p>接口被以两种不同的方式使用。</p>
<p>在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，<strong>一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。</strong>重点在于方法上，而不是具体的类型上。</p>
<p>第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。<strong>类型断言用来动态地区别这些类型，使得对每一种情况都不一样</strong>。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。</p>
<p>将每一个参数值转换成它的SQL字面量符号：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;database/sql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listTracks</span><span class="params">(db sql.DB, artist <span class="type">string</span>, minYear, maxYear <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    result, err := db.Exec(</span><br><span class="line">        <span class="string">&quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;</span>,</span><br><span class="line">        artist, minYear, maxYear)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">uint</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> b, ok := x.(<span class="type">bool</span>); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s, ok := x.(<span class="type">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(s) <span class="comment">// (not shown)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:       <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>: <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:      <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。</p>
<p>当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。</p>
<p>default case相对其它case的位置是无所谓的。它不会允许落空发生。</p>
<p>原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123; <span class="comment">// x原类型interface&#123;&#125;，经过断言改为对应类型</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x) <span class="comment">// x has type interface&#123;&#125; here.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(x) <span class="comment">// (not shown)</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。</p>
<p>例如，变量x在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量x是switch运算对象的类型（接口）；在这个例子中运算对象是一个interface{}。当多个case需要相同的操作时，比如int和uint的情况，类型分支可以很容易的合并这些情况。</p>
<p>尽管sqlQuote接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出“unexpected type”消息。虽然x的类型是interface{}，但是我们把它认为是一个int，uint，bool，string，和nil值的discriminated union（可识别联合）</p>
<h3 id="示例-基于标记的XML解码"><a href="#示例-基于标记的XML解码" class="headerlink" title="示例: 基于标记的XML解码"></a>示例: 基于标记的XML解码</h3><p>encoding/xml包提供了一个基于标记的API用于XML解码。</p>
<p>在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－StartElement，EndElement，CharData，和Comment－每一个都是encoding/xml包中的具体类型。每一个对(*xml.Decoder).Token的调用都返回一个标记。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xml</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name <span class="keyword">struct</span> &#123;</span><br><span class="line">    Local <span class="type">string</span> <span class="comment">// e.g., &quot;Title&quot; or &quot;id&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Attr <span class="keyword">struct</span> &#123; <span class="comment">// e.g., name=&quot;value&quot;</span></span><br><span class="line">    Name  Name</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Token includes StartElement, EndElement, CharData,</span></span><br><span class="line"><span class="comment">// and Comment, plus a few esoteric types (not shown).</span></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> StartElement <span class="keyword">struct</span> &#123; <span class="comment">// e.g., &lt;name&gt;</span></span><br><span class="line">    Name Name</span><br><span class="line">    Attr []Attr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> EndElement <span class="keyword">struct</span> &#123; Name Name &#125; <span class="comment">// e.g., &lt;/name&gt;</span></span><br><span class="line"><span class="keyword">type</span> CharData []<span class="type">byte</span>                 <span class="comment">// e.g., &lt;p&gt;CharData&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">type</span> Comment []<span class="type">byte</span>                  <span class="comment">// e.g., &lt;!-- Comment --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Decoder <span class="keyword">struct</span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(io.Reader)</span></span> *Decoder</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Decoder)</span></span> Token() (Token, <span class="type">error</span>) <span class="comment">// returns next Token in sequence</span></span><br></pre></td></tr></table></figure>

<p>这个没有方法的Token接口也是一个可识别联合的例子。</p>
<p>传统的接口如io.Reader的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现：在这个实现中每个具体类型都被统一地对待。</p>
<p>相反，满足可识别联合的具体类型的集合被设计为确定和暴露，而不是隐藏。可识别联合的类型几乎没有方法，操作它们的函数使用一个类型分支的case集合来进行表述，这个case集合中每一个case都有不同的逻辑。</p>
<p>下面的xmlselect程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要实例化这个文档树。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xmlselect prints the text of selected elements of an XML document.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dec := xml.NewDecoder(os.Stdin)</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="type">string</span> <span class="comment">// stack of element names</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        tok, err := dec.Token()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;xmlselect: %v\n&quot;</span>, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> tok := tok.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> xml.StartElement:</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, tok.Name.Local) <span class="comment">// push</span></span><br><span class="line">        <span class="keyword">case</span> xml.EndElement:</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// pop</span></span><br><span class="line">        <span class="keyword">case</span> xml.CharData:</span><br><span class="line">            <span class="keyword">if</span> containsAll(stack, os.Args[<span class="number">1</span>:]) &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%s: %s\n&quot;</span>, strings.Join(stack, <span class="string">&quot; &quot;</span>), tok)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// containsAll reports whether x contains the elements of y, in order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsAll</span><span class="params">(x, y []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(y) &lt;= <span class="built_in">len</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> x[<span class="number">0</span>] == y[<span class="number">0</span>] &#123;</span><br><span class="line">            y = y[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        x = x[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中的循环每遇到一个StartElement时，它把这个元素的名称压到一个栈里，并且每次遇到EndElement时，它将名称从这个栈中推出。这个API保证了StartElement和EndElement的序列可以被完全的匹配，甚至在一个糟糕的文档格式中。注释会被忽略。当xmlselect遇到一个CharData时，只有当栈中有序地包含所有通过命令行参数传入的元素名称时，它才会输出相应的文本。</p>
<p>下面的命令打印出任意出现在两层div元素下的h2元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 |</span><br><span class="line">    ./xmlselect div div h2</span><br><span class="line">html body div div h2: 1 Introduction</span><br><span class="line">html body div div h2: 2 Documents</span><br><span class="line">html body div div h2: 3 Logical Structures</span><br><span class="line">html body div div h2: 4 Physical Structures</span><br><span class="line">html body div div h2: 5 Conformance</span><br><span class="line">html body div div h2: 6 Notation</span><br><span class="line">html body div div h2: A References</span><br><span class="line">html body div div h2: B Definitions for Character Normalization</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><p>当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。</p>
<p>不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。</p>
<p>你可以使用导出机制来限制一个类型的方法或一个结构体的字段是否在包外可见。</p>
<p><strong>接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</strong></p>
<p><strong>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</strong></p>
<p>因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）</p>
<p>我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像input.Scan这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如fmt.Printf。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="http://books.studygolang.com/gopl-zh">Go语言圣经（中文版）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34204722/article/details/92112954">命令行参数（flag包）</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry"><span class="miit">
                <img src="/img/gov.png" title="中华人民共和国工业和信息化部">
                <a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">辽ICP备20002229号-1</a>
        </span>
    
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
